---
layout: single
categories:
    - programmers
tags:
    - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤
    - ì½”í…Œ
comments: true
title: "í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ - ê·¸ë˜í”„(ê°€ì¥ ë¨¼ ë…¸ë“œ, ìˆœìœ„, ë°©ì˜ ê°œìˆ˜)"
---


ë¬¸ì œ ë§í¬ - [https://programmers.co.kr/learn/courses/30/parts/14393](https://programmers.co.kr/learn/courses/30/parts/14393){:target="_blank"}

## ğŸ‘€ë¬¸ì œì´í•´ ë° í’€ì´ë°©ë²•
ê·¸ë˜í”„ ë¬¸ì œì´ë‹¤ ìì‹ ìˆëŠ” ìœ í˜•ì¸ë° ë¬¸ì œê°€ ì–´ë ¤ì› ë˜ ê±´ì§€ ë˜ ë§‰í˜”ë‹¤ ã… ã…  ë°±ì¤€ ì¢€ë” í’€ë©´ì„œ ë³µìŠµí•  ì˜ˆì •ì´ë‹¤<br>
1ë²ˆë¬¸ì œëŠ” ë¹„êµì  ê°„ë‹¨í•˜ê²Œ bfsë¡œ í’€ì—ˆë‹¤ ê° ë…¸ë“œì— 1ë²ˆë…¸ë“œ ë¶€í„°ì˜ ê±°ë¦¬ë¥¼ ì €ì¥í•˜ê³  ê·¸ë•Œë§ˆë‹¤ ìµœëŒ€ ê±°ë¦¬ë¥¼ ê°±ì‹ í•˜ë©° ë§ˆì§€ë§‰ì— ìµœëŒ€ê±°ë¦¬ì™€ ê°™ì€ ë…¸ë“œë“¤ì„ ì„¸ì–´ì£¼ë©´ ë˜ëŠ” ë¬¸ì œì˜€ë‹¤<br>
2ë²ˆ ë¬¸ì œëŠ” ì•„ì§ë„ ì´í•´ê°€ ì˜ ì•ˆëœë‹¤ ê²°êµ­ ê²€ìƒ‰í•´ì„œ í”Œë¡œì´ë“œ ì™€ì…œ ë¬¸ì œë¼ëŠ” ê²ƒì„ ì•Œê³  í’€ì—ˆëŠ”ë° ì´ê²Œ ì™œ.. ë¼ëŠ” ìƒê°ì´ ë“¤ê³  ë‚˜ì¤‘ì— ë¹„ìŠ·í•œ ë¬¸ì œê°€ ë‚˜ì™”ì„ ë•Œ ëª»í’€ê²ƒ ê°™ì€ ëŠë‚Œì´ ë“¤ì—ˆë‹¤ ì²˜ìŒì—ëŠ” setì„ ì´ìš©í•´ ê° ë…¸ë“œì˜ ìœ„ ì•„ë˜ ìˆœìœ„ë¥¼ ë‹¤ ì²´í¬í•˜ë©´ì„œ í’€ì–´ë³´ë ¤ê³  í–ˆëŠ”ë° ì–´ë”˜ê°€ ë¹ íŠ¸ë¦°ê²Œ ìˆëŠ”ì§€ ì˜ í’€ë¦¬ì§€ ì•Šì•˜ë‹¤<br>
3ë²ˆ ë¬¸ì œëŠ” ê°€ì¥ ë‚œì´ë„ê°€ ë†’ë‹¤ê³  í•˜ëŠ”ë° ê·¸ë ‡ê²Œê¹Œì§€ ì–´ë µì§€ëŠ” ì•Šì•˜ë‹¤ ëŒ€ê°ìœ¼ë¡œ ê²¹ì¹˜ëŠ” ë¶€ë¶„ì„ ì²´í¬í•˜ê¸° ìœ„í•´ ê° ì´ë™ì„ 2ë²ˆì”© ì‹œí‚¤ëŠ” ê²ƒì„ ìºì¹˜í•œë‹¤ë©´ ê¸ˆë°© ì´í•´í•  ìˆ˜ ìˆë‹¤. ì¼ë‹¨ ê·¸ë¦° ì„ ë¶„ê³¼ ë„ë‹¬í•œ ì •ì ë“¤ì„ ì €ì¥í•´ ë‘ê³  ì„ ë¶„ì´ ì§€ë‚˜ê°„ì  ì—†ëŠ” ì„ ë¶„ì´ë©´ì„œ ì •ì ì´ ì´ë¯¸ ê°”ë˜ ì •ì ì´ë¼ë©´ sol++; í•´ì£¼ë©´ ë˜ì—ˆë‹¤<br>
ì´ë¡œì„œ í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ ë¬¸ì œë“¤ì€ ë§ˆë¬´ë¦¬ë¥¼ ì§€ì—ˆê³  ë‚´ì¼ levelí…ŒìŠ¤íŠ¸ë¥¼ ì¢€ ë³´ê³  ì•ìœ¼ë¡œëŠ” ë°±ì¤€ìœ„ì£¼ë¡œ ê³µë¶€í•˜ê²Œ ë ê²ƒ ê°™ë‹¤ğŸ‘<br>

## ğŸ“ì½”ë“œ
1 ê°€ì¥ ë¨¼ ë…¸ë“œ
  
```cpp
#include <string>
#include <vector>
#include <queue>
using namespace std;
struct _node{
    int dis;
    vector<int> connect;
};
class test1{
private:
    vector<_node> graph;
    int N;
public:
    test1(int n):N(n){
        graph.resize(N+1,{-1,});
        graph[1].dis=0;
    }
    void set_connect(vector<vector<int>>& edge){
        for(int i=0;i<edge.size();i++){
            graph[edge[i][0]].connect.push_back(edge[i][1]);
            graph[edge[i][1]].connect.push_back(edge[i][0]);
        }
    }
    int find_sol(){
        int M=0;
        queue<pair<int,int>> q;
        q.push({1,0});
        pair<int,int> cur;
        while(!q.empty()){
            cur = q.front();
            q.pop();
            M=max(cur.second,M);
            for(int i : graph[cur.first].connect){
                if(graph[i].dis==-1){
                    graph[i].dis=cur.second+1;
                    q.push({i,cur.second+1});
                }
            }
        }
        int sol=0;
        for(int i=1;i<graph.size();i++){
            if(graph[i].dis==M)
                sol++;
        }
        return sol;
    }
};

int solution(int n, vector<vector<int>> edge) {
    test1 t1(n);
    t1.set_connect(edge);
    return t1.find_sol();
}
```
  
2 ìˆœìœ„
  
```cpp
#include <iostream>
#include <string>
#include <vector>
using namespace std;

int solution(int n, vector<vector<int>> results) {
    int answer =0;
    vector<vector<bool>> graph(n+1,vector<bool>(n+1,false));
    for(auto i : results)
        graph[i[0]][i[1]]=true;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            for(int l=0;l<=n;l++){
                if(graph[j][i] && graph[i][l])
                    graph[j][l]=true;
            }
        }
    }
    for(int i=1;i<=n;i++){
        int cnt =0;
        for(int j=1;j<=n;j++)
            if(graph[i][j] || graph[j][i])
                cnt++;
        if(cnt==n-1)
            answer++;
    }
    return answer;
}
```
  
3 ë°©ì˜ ê°œìˆ˜
  
```cpp
#include <iostream>
#include <string>
#include <vector>
#include <map>
using namespace std;
int dx[8]={-1,-1,0,1,1,1,0,-1};
int dy[8]={0,1,1,1,0,-1,-1,-1};
class structnum{
private:
    vector<int> arrows;
public:
    structnum(vector<int>& a):arrows(a){

    }
    int find_sol(){
        int sol=0;
        map<pair<int,int>,bool> point;
        map<pair<pair<int,int>,pair<int,int>>,bool> M;
        int x=0,y=0;
        int nx,ny;
        point[{x,y}]=true;
        for(int i : arrows){
            for(int j=0;j<2;j++){
                nx=x+dx[i],ny=y+dy[i];
                if(!M[{x,y},{nx,ny}]){
                    M[{x,y},{nx,ny}]=true;
                    M[{nx,ny},{x,y}]=true;
                    if(point[{nx,ny}])
                        sol++;
                }
                point[{nx,ny}]=true;
                x=nx,y=ny;
            }
        }
        return sol;
    }
};
int solution(vector<int> arrows) {
    structnum st(arrows);
    return st.find_sol();
}
```
  