---
layout: single
categories:
    - programmers
tags:
    - í”„ë¡œê·¸ë˜ë¨¸ìŠ¤
    - ì½”í…Œ
comments: true
title: "í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ - dfs/bfs(íƒ€ê²Ÿ ë„˜ë²„, ë„¤íŠ¸ì›Œí¬, ë‹¨ì–´ ë³€í™˜, ì—¬í–‰ê²½ë¡œ)"
---


ë¬¸ì œ ë§í¬ - [https://programmers.co.kr/learn/courses/30/parts/12421](https://programmers.co.kr/learn/courses/30/parts/12421){:target="_blank"}

## ğŸ‘€ë¬¸ì œì´í•´ ë° í’€ì´ë°©ë²•
ì˜¤ëŠ˜ì€ dfs/bfs ë¬¸ì œë“¤ì„ í’€ì—ˆë‹¤ ìµœê·¼ì—ë„ ê·¸ë ‡ê³  ì •ë§ ë§ì´ í’€ì—ˆë˜ ìœ í˜•ë“¤ì´ë¼ ê¸ˆë°© ì˜ í’€ë¦°ê²ƒ ê°™ë‹¤.<br>
ë¬¸ì œë“¤ì€ ì¬ë¯¸ìˆì—ˆëŠ”ë° ë§ˆì§€ë§‰ 4ë²ˆ ì—¬í–‰ê²½ë¡œê°€ ì¡°ê¸ˆ ë‚œí•´í–ˆë‹¤ ë¬¸ì œ ì´í•´ë„ ê·¸ë ‡ê³  ì´í•´ í–ˆë”ë¼ë„ ë°±íŠ¸ë˜í‚¹ì„ ì“°ê³ ì‹¶ì—ˆëŠ”ë° êµ¬í˜„ì´ ìƒê°ë§í¼ ì‰½ì§€ ì•Šì•˜ë‹¤ ê²°êµ­ visitë°°ì—´ì„ í¬ê¸°í•˜ê³  setìœ¼ë¡œ ì§€ê¸ˆê¹Œì§€ ì§€ë‚˜ì˜¨ ê³³ì„ í‘œí˜„í•˜ë©´ì„œ dfsë¥¼ ëŒë ¸ë‹¤<br>
ì¡°ê¸ˆ ë‚œí•´í•˜ê¸´ í•´ì„œ ë‹¤ë¥¸ ì½”ë“œë¥¼ ê³µë¶€í•´ë³¼ ì˜ˆì •ì´ë‹¤.<br>
1 2 3 ë²ˆë¬¸ì œëŠ” ë¬¸ì œê°€ ê¸°ì–µì´ ì˜ ë‚˜ì§€ ì•Šì„ì •ë„ë¡œ ê¸ˆë°© í’€ë¦°ê²ƒ ê°™ë‹¤<br>


## ğŸ“ì½”ë“œ
1 íƒ€ê²Ÿ ë„˜ë²„
  
```cpp
#include <iostream>
#include <string>
#include <vector>
using namespace std;
class problem1{
private:
    vector<int> numbers;
    int target,sol=0;
public:
    problem1(vector<int>& n,int t):numbers(n),target(t){

    }
    void dfs(int cur,int p){
        if(p==numbers.size()){
            if(cur==target)
                sol++;
            return ;
        }
        dfs(cur+numbers[p],p+1);
        dfs(cur-numbers[p],p+1);
    }
    int find_sol(){
        dfs(0,0);
        return sol;
    }
};
int solution(vector<int> numbers, int target) {
    problem1 p1(numbers,target);

    return p1.find_sol();
}
```
  
2 ë„¤íŠ¸ì›Œí¬
  
```cpp
#include <iostream>
#include <string>
#include <vector>
#include <queue>
using namespace std;
class bfs_basic{
private:
    vector<vector<int>> computers;
    int N;
    vector<bool> visit;
public:
    bfs_basic(int n,vector<vector<int>>& c):N(n),computers(c){
        visit.resize(N,false);
    }
    void bfs(int start){
        queue<int> q;
        q.push(start);
        visit[start]=true;
        int cur;
        while(!q.empty()){
            cur = q.front();
            q.pop();
            for(int i=0;i<computers[cur].size();i++){
                if(computers[cur][i] && !visit[i]){
                    visit[i]=true;
                    q.push(i);
                }
            }
        }
    }
    int find_sol(){
        int sol=0;
        for(int i=0;i<N;i++){
            if(!visit[i]){
                bfs(i);
                sol++;
            }
        }
        return sol;
    }   
};
int solution(int n, vector<vector<int>> computers) {
    bfs_basic bb(n,computers);
    return bb.find_sol();
}
```
  
3 ë‹¨ì–´ ë³€í™˜
  
```cpp
#include <string>
#include <vector>
#include <queue>
using namespace std;
struct _node{
    string str;
    int degree;
};
int solution(string begin, string target, vector<string> words) {
    queue<_node> q;
    q.push({begin,0});
    vector<bool> visit(words.size());
    _node cur;
    int cnt;
    while(!q.empty()){
        cur = q.front();
        q.pop();
        if(cur.str == target)
            return cur.degree;
        for(int i=0;i<words.size();i++){
            cnt=0;
            for(int j=0;j<words[i].size();j++)
                if(words[i][j]!=cur.str[j])
                    cnt++;
            if(cnt ==1 && !visit[i]){
                visit[i]=true;
                q.push({words[i],cur.degree+1});
            }
        }
    }
    return 0;
}
```
  
4 ì—¬í–‰ê²½ë¡œ
  
```cpp
#include <iostream>
#include <string>
#include <vector>
#include <stack>
#include <algorithm>
#include <unordered_set>
using namespace std;
bool compare(vector<string>& a, vector<string>& b){
    return a[1]>b[1];  
};
vector<string> solution(vector<vector<string>> tickets) {
    vector<string> answer(tickets.size()+1);
    sort(tickets.begin(),tickets.end(),compare);
    stack<pair<string,unordered_set<int>>> st;
    st.push({"ICN",{}});
    pair<string,unordered_set<int>> cur;
    while(!st.empty()){
        cur = st.top();
        st.pop();
        answer[cur.second.size()]=cur.first;
        if(cur.second.size()==tickets.size())
            return answer;
        for(int i=0;i<tickets.size();i++){
            if(tickets[i][0]==cur.first && cur.second.find(i)==cur.second.end()){
                unordered_set<int> tmp = cur.second;
                tmp.insert(i);
                st.push({tickets[i][1],tmp});
            }
        }
    }
}
```
