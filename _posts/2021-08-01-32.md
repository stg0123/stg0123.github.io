---
layout: single
categories:
    - baekjoon
tags:
    - baekjoon
    - ë°±ì¤€
    - ì½”í…Œ
comments: true
title: "ë°±ì¤€(boj)6059 - Pasture Walking"
---


ë¬¸ì œ ë§í¬ - [https://www.acmicpc.net/problem/6059](https://www.acmicpc.net/problem/6059){:target="_blank"}

## ğŸ‘€ë¬¸ì œì´í•´ ë° í’€ì´ë°©ë²•
ê°€ì¥ ì „í˜•ì ì¸ íŠ¸ë¦¬ lcaë¬¸ì œì´ë‹¤. íŠ¸ë¦¬ì˜ ê°„ì„ ë§ˆë‹¤ ê¸¸ì´ê°€ ìˆê³  ë‘ ì •ì ì˜ ê±°ë¦¬ë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œì´ë‹¤.<br>
2ì°¨ì› disë°°ì—´ì„ ì‚¬ìš©í•´ì„œ ë‘ ì •ì ê°„ì˜ ê±°ë¦¬ë¥¼ ì–‘ë°©í–¥ ëª¨ë‘ ì…ë ¥í•´ ë‘”ë‹¤ ì´ë¥¼ í†µí•´ì„œ rootë¥¼ 1ë¡œ ì •í•´ì„œ maketreeë¥¼ í†µí•´ íŠ¸ë¦¬ë¥¼ ë§Œë“¤ë©° ê° nodeë§ˆë‹¤ ë¶€ëª¨ nodeì™€ ê¹Šì´, rootì™€ì˜ ê±°ë¦¬ë¥¼ ì €ì¥í–ˆë‹¤.<br>
ì´í›„ ë‘ ì •ì ì˜ depthë¥¼ í†µí•´ lcaë¥¼ ì°¾ì•„ ë‘ ì •ì ì´ ê°€ì§„ rootì™€ì˜ ê±°ë¦¬ì˜ í•©ì—ì„œ lcaì˜ rootì™€ì˜ ê±°ë¦¬*2ë¥¼ ë¹¼ì£¼ë©´ ë‹µì´ ë‚˜ì˜¨ë‹¤ ì²˜ìŒì— *2ë¥¼ ì•ˆí•´ì„œ í‹€ë ¸ì—ˆë‹¤.ğŸ˜¥<br>
íŠ¸ë¦¬ ë¬¸ì œì¤‘ ê¼­ í’€ì–´ë´ì•¼í•˜ëŠ” ë¬¸ì œì¤‘ í•˜ë‚˜ë¼ê³  ìƒê°í•œë‹¤.<br>

## ğŸ“ì½”ë“œ
  
```cpp
#include <iostream>
#include <vector>
using namespace std;
struct _node{
    int parent;
    int depth;
    int dis;
};
class walking{
private:
    vector<_node> tree;
    vector<vector<int>> dis;
    int N,Q;
public:
    walking(){
        std::cin >> N >> Q;
        tree.resize(N+1,{0,0,});
        dis.resize(N+1,vector<int>(N+1,0));
        set_connect();
        maketree(1,0,1,0);
    }
    void set_connect(){
        int a,b,d;
        for(int i=1;i<N;i++){
            std::cin >>a >> b>> d;
            dis[a][b]=d;
            dis[b][a]=d;
        }
    }
    void maketree(int cur,int parent,int depth,int d){
        tree[cur].parent=parent;
        tree[cur].depth=depth;
        tree[cur].dis=d;
        for(int i=1;i<=N;i++)
            if(dis[cur][i] && i!=parent)
                maketree(i,cur,depth+1,d+dis[cur][i]);
    }
    int lca(int a,int b){
        int sol = tree[a].dis+tree[b].dis;
        if(tree[a].depth>tree[b].depth)
            swap(a,b);
        while(tree[a].depth!=tree[b].depth)
            b=tree[b].parent;
        if(a==b)
            return sol-tree[a].dis*2;
        while(a!=b){
            a=tree[a].parent;
            b=tree[b].parent;
        }
        return sol-tree[a].dis*2;
    }
    void find_sol(){
        int a,b;
        for(int i=0;i<Q;i++){
            std::cin >> a >> b;
            std::cout << lca(a,b) << '\n';   
        }
    }
};
int main(){
    cin.tie(NULL);cout.tie(NULL);
    ios_base::sync_with_stdio(false);
    walking wk;
    wk.find_sol();
    return 0;
}
```

![image](/assets/images/baekjoon/6059_1.png){:.align-center}  <br>